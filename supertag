#!/usr/bin/perl -w

# TODO switch to a codec-specific plugin architecture

use Getopt::Long;
use Cwd qw/realpath/;
use Errno qw/:POSIX/;
use MP3::Info qw/get_mp3tag set_mp3tag get_mp3info/;
use Audio::FLAC::Header;
use strict;

our $VERSION = '0.01';

my %known_tags = (
  'ALBUM'    => 'A',
  'ARTIST'   => 'a',
  'TITLE',   => 't',
  'TRACKNUM' => 'T',
  'YEAR',    => 'y',
  'GENRE',   => 'G',
  'COMPOSER' => 'c',
  'COMMENT'  => 'C',
);

my %known_sources = (
  'id3v1'    => '1',
  'id3v2'    => '2',
  'flac'     => 'F',
  'filename' => 'N',
  'audio'    => 'I',
  'codec'    => 'E',
);

my %source_priority = do {
  my $i = 0;
  map { $_ => $i++ } qw/options id3v2 id3v1 flac filename audio codec/;
};

my %mime2ext = (
  'audio/mpeg'   => 'mp3',
  'audio/x-flac' => 'flac',
);

my %ext2mime = map { $mime2ext{$_} => $_ } keys %mime2ext;

my @getopt = (
  qw/get|g
     set|s
     help|h
     verbose|v
     dry|n
     library|L=s
     mime
     rename-pattern|p=s
     capture-pattern|P=s/,
  (map "$_|$known_sources{$_}!" => keys %known_sources),
  (map "$_|".lc($_)."|$known_tags{$_}:s" => keys %known_tags),
);

my %opt = (
  'id3v1'    => 1,
  'id3v2'    => 1,
  'flac'     => 1,
  'filename' => 1,
  'rename-pattern' => '%a_-_%A/%02T._%a_-_%t',
  'capture-pattern' => '%a_-_%A/%02T._%a_-_%t',
);

if (-e (my $config_file = "$ENV{HOME}/.supertag/config")) {
  my $config = read_config($config_file);
  my $newopt = hash_union($config, \%opt);
  %opt = %$newopt;
}

Getopt::Long::Configure('bundling', 'no_ignorecase');
GetOptions(\%opt, @getopt) or die;


if ($opt{set}) {

  while (<STDIN>) {
    chomp;

    my %tags =
      map { s/%(\d\d)/chr(hex($1))/ge; $_ } 
        map split(/=/, $_, 2) => split /\|/;

    set_tags(\%tags);
  }
}
elsif ($opt{get}) {

  # TODO allow user to set source priority through order of options

  my @sources = 
    sort { $source_priority{$a} <=> $source_priority{$b} }
        ('options', grep $opt{$_} => keys %known_sources);

  my $have_argv = @ARGV;

  while (my $file = $have_argv ? shift @ARGV : <STDIN>) {
    chomp $file;

    my $tags = {};

    $tags = hash_union($tags, get_tags($file, $_)) for @sources;

    print join "|" =>
      map { s/([^[:print:]]|%|\|)/"%".sprintf('%02x',ord($1))/ge; $_ }
        map "$_=$tags->{$_}" =>
          grep defined $tags->{$_} =>
            sort keys %$tags;

    print "\n";
  }
}

exit 0;


sub get_tags {
  my $file = shift;
  my $source = shift;
  my $tags;

  $tags =
    $source eq 'options' ?
      { map { exists $opt{$_} ? ($_=>$opt{$_}) : () } keys %known_tags }
    :
    $source eq 'filename' ?
      scan_filename($file, $opt{'capture-pattern'})
    :
    $source =~ /^id3v(1|2)$/ ?
      (filetype($file) eq 'audio/mpeg' ? get_mp3tag($file, $1) : {})
    :
    $source eq 'flac' ?
      (filetype($file) eq 'audio/x-flac' ?
         Audio::FLAC::Header->new($file)->tags : {})
    :
    $source eq 'audio' ? do {
      if (filetype($file) eq 'audio/mpeg') {
        my $info = get_mp3info($file);
        my %tags = (
          SECS => $info->{SECS},
          SAMPLERATE => $info->{FREQUENCY} * 1000,
          NUMCHANNELS => $info->{STEREO} ? 2 : 1
        );
        \%tags;
      }
      elsif (filetype($file) eq 'audio/x-flac') {
        my $info = Audio::FLAC::Header->new($file)->info;
        my %tags = (
          SECS => $info->{trackTotalLengthSeconds},
          SAMPLERATE => $info->{SAMPLERATE},
          NUMCHANNELS => $info->{NUMCHANNELS}
        );
        \%tags;
      }
    } :
    $source eq 'codec' ? do {
      if (filetype($file) eq 'audio/mpeg') {
        my $info = get_mp3info($file);
        my %tags = map (("MP3_$_" => $info->{$_}) => keys %$info);
        \%tags;
      }
      else {
        my $info = Audio::FLAC::Header->new($file)->info;
        my %tags = map (("FLAC_$_" => $info->{$_}) => keys %$info);
        \%tags;
       }
    } :
    die "unrecognized tag source $source";

  $tags->{PATH} = realpath($file);     # pseudo tag

  return normalize_tags($tags);
}

sub set_tags {
  my $tags = shift;

  for (grep exists $opt{$_} => keys %known_tags) {
    $tags->{$_} = $opt{$_};
  }

  my $file = $tags->{PATH};

  my %set_tags =
    map { defined $tags->{$_} ? ($_ => $tags->{$_}) : () }
      keys %known_tags;

    if (filetype($file) eq 'audio/mpeg' && $opt{id3v1}) {
      if ($opt{dry}) {
        print "id3v1: setting tags for $file\n";
      }
      else {
        # FIXME apparently MP3::Info only sets id3v1? 
        set_mp3tag($file, \%set_tags);
      }
    }
    elsif (filetype($file) eq 'audio/x-flac' && $opt{flac}) {
      if ($opt{dry}) {
        print "flac: setting tags for $file\n";
      }
      else {
        my $flac = Audio::FLAC::Header->new($file);
        $set_tags{TRACKNUMBER} = delete $set_tags{TRACKNUM};
        $flac->{tags} = \%set_tags;
        $flac->write();
      }
    }

  if ($opt{filename}) {
    my $newfile = format_filename($opt{'rename-pattern'}, $tags);

    $newfile = join '/' => ($opt{library}, $newfile) if $opt{library};
    $newfile = join '.' => $newfile, $mime2ext{filetype($file)};

    if ($newfile ne $file) {
      if ($opt{dry}) {
        print "rename: $file => $newfile\n";
      }
      else {
        ensure_dir(dirname($newfile));

        rename $file => $newfile or
          die "mv $file => $newfile failed: $!";
      }
    }
  }

}

sub read_config {
  my $file = shift;
  my %config;

  open my $fh, '<', $file or
    die "error reading config file $file: $!";

  while (<$fh>) {
    chomp;
    s/^\s+//;
    s/\s+$//;

    next if not $_;
    next if substr($_, 0, 1) eq '#';

    if (/^([^= ]+)\s*=\s*(.*)$/) {
      $config{$1} = $2;
    }
    else {
      die qq{config syntax error, line $.: "$_"};
    }
  }
  
  close $fh or
    die "error reading config file $file: $!";

  return \%config;
}

sub normalize_tags {
  my $tags = shift;

  # standardize on uppercase tag names

  %$tags = map { uc $_ => $tags->{$_} } keys %$tags;

  if (exists $tags->{TRACKNUMBER}) {
    $tags->{TRACKNUM} = delete $tags->{TRACKNUMBER};
  }

  if (($tags->{TRACKNUM}||'') =~ /^(\d+)/) {
    $tags->{TRACKNUM} = $1;
  }
  elsif ($tags->{TRACKNUM}) {
    die "bad track tag: $tags->{TRACKNUM}";
  }

  for (keys %$tags) {
    if ('ARRAY' eq ref $tags->{$_}||'') {
      $tags->{$_} = join "\n" => @{$tags->{$_}};
    }
  }

  return $tags;
}

sub filetype {
  my $file = shift;

  if ($opt{mime}) {
    open my $fh, '-|', '/usr/bin/file', '-i', '-b', $file or
      die "error running file(1): $!";

    my $mime = <$fh>; chomp $mime;

    close $fh or
      die "error running file(1): $!";

    return $mime;
  }
  else {
    my $ext = ($file =~ /\.([^\.]+)$/)[0];

    return $ext2mime{$ext};
  }
}

sub scan_filename {
  my $file = shift;
  my $pattern = shift;
  my $delim = '_';
  my %spec = map { $known_tags{$_} => $_ } keys %known_tags;
  my @match_names;
 
  $pattern =~ s!([^a-zA-Z0-9_ %/-])!\\$1!g;
  $pattern =~ s/%([a-zA-Z])/push @match_names, $spec{$1}; "(.*?)"/eg;

  for my $try ($file, basename($file)) {
    if ((my @matches = ($try =~ qr/$pattern/))) {
      my %tags;

      for (my $i=0; $i<@matches; $i++) {
        $tags{$match_names[$i]} = $matches[$i];
      }

      return \%tags;
    }
  }

  return {};
}

sub format_filename {
  my $pattern = shift;
  my $tags = shift;
  my %abbrev = map { $known_tags{$_} => $_ } keys %known_tags;

  my $specsub = sub {
    my ($width, $format) = @_;
    my $value = $tags->{$abbrev{$format}};
    my $type;

    $width = '' if not defined $width;
    $value = '' if not defined $value;
    $type = $format eq 'T' ? 'd' : 's';

    return sprintf "%${width}${type}" => path_sanitize($value);
  };

  my $file = $pattern;
  $file =~ s/%(\d*)([a-zA-Z])/$specsub->($1,$2)/ge;
  return $file;
}

sub path_sanitize {
  my $str = shift;

  # TODO crib odd char set from soundjuicer?
  $str =~ s! !_!g;
  $str =~ s![^[:print:]]!_!g;
  $str =~ s![/\\\*:]!_!g;

  return $str;
}

sub ensure_dir {
  my $dir = shift;
  my @parts = split m{/} => $dir;
  my $x = '';

  while (@parts) {
    $x .= '/' . shift @parts;
    if ($x && !-d $x) {
      mkdir $x or $!{EEXIST} or do die "mkdir error for $x: $!";
    }
  }
}

sub dirname {
  return $1 if $_[0] =~ m{^(.+)/([^/]+)$};
  return;
}

sub basename {
  return $_[0] =~ m{([^/]+)$} ? $1 : $_[0];
}

sub hash_union {
  my %h;

  for my $k (map keys %$_ => @_) {
    for my $v (map $_->{$k} => @_) {
      $h{$k} = $v unless defined $h{$k};
    }
  }

  return \%h;
}

__END__

=head1 SYNOPSIS

supertag - manage your music collection like a real man.

=head1 DESCRIPTION

TODO write me

=head1 EXAMPLES

TODO write me

=head1 OPTIONS

operating modes:
  -g get tag info (the default mode)
  -s set tag info

operands:
  -1 operate on id3v1 tags (mp3 only)
  -2 operate on id3v2 tags (mp3 only)
  -F operate on flac tags (flac only)
  -N operate on filenames
  -p PATTERN format string for renaming files
  -P PATTERN format string for scraping filenames

tags:
  -A album
  -a artist
  -t title
  -T track number
  -y year
  -g genre
  -c composer
  -C comment

flags:
  -m, --mime     use file(1) to determine file type - slower, off by default
  -n, --dry      dry run (don't modify anything)
  -v, --verbose  verbose

=head1 AUTHOR

Alan Grow <agrow+nospam@thegotonerd.com>

=head1 COPYRIGHT

Copyright (C) 2008 by Alan Grow

This application is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.3 or, at
your option, any later version of Perl 5 you may have available.

=cut

