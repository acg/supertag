#!/usr/bin/perl -w

use Getopt::Long;
use Cwd qw/realpath/;
use Errno qw/:POSIX/;
use Audio::SuperTag::Plugin;
use strict;

our $VERSION = '0.01';

my %known_tags = (
  'ALBUM'    => 'A',
  'ARTIST'   => 'a',
  'TITLE',   => 't',
  'TRACKNUM' => 'T',
  'YEAR',    => 'y',
  'GENRE',   => 'G',
  'COMPOSER' => 'c',
  'COMMENT'  => 'C',
);

my %known_sources = (
  'id3v1'    => '1',
  'id3v2'    => '2',
  'flac'     => 'F',
  'filename' => 'N',
  'audio'    => 'I',
  'codec'    => 'E',
);

my @default_sources = qw/id3v2 id3v1 flac filename/;
my %sources;

my %mime2ext = (
  'audio/mpeg'   => 'mp3',
  'audio/x-flac' => 'flac',
);

my %ext2mime =
  map { $mime2ext{$_} => $_ } keys %mime2ext;

my %plugins =
  map { my $p = load_plugin($_); $p ? ($_=>$p) : () } values %mime2ext;

my $opt = {
  'rename-pattern' => '%a_-_%A/%02T._%a_-_%t',
};

if (-e (my $config_file = "$ENV{HOME}/.supertag/config")) {
  my $config = read_config($config_file);
  $opt = hash_union($config, $opt);
}

parse_options();


if ($opt->{set}) {

  while (<STDIN>) {
    chomp;

    my %tags =
      map { s/%(\d\d)/chr(hex($1))/ge; $_ } 
        map split(/=/, $_, 2) => split /\|/;

    die "error, missing PATH field: unable to set tags" unless
      $tags{PATH};

    my $mime = filetype($tags{PATH});
    my $codec = $mime2ext{$mime};
    my $obj = "$plugins{$codec}"->new($tags{PATH});

    set_tags($obj, \%tags);
  }
}
elsif ($opt->{get}) {

  my @sources = 
    ('options', sort { $sources{$a} <=> $sources{$b} } keys %sources);

  my $have_argv = @ARGV;

  while (my $file = $have_argv ? shift @ARGV : <STDIN>) {
    chomp $file;

    my $mime = filetype($file);
    my $codec = $mime2ext{$mime};
    my $obj = "$plugins{$codec}"->new($file);
    my $tags = {};

    $tags = hash_union($tags, get_tags($obj, $_)) for @sources;

    print join "|" =>
      map { s/([^[:print:]]|%|\|)/"%".sprintf('%02x',ord($1))/ge; $_ }
        map "$_=$tags->{$_}" =>
          grep defined $tags->{$_} =>
            sort keys %$tags;

    print "\n";
  }
}
elsif ($opt->{version}) {
  print "supertag $VERSION\n";
  print "plugins: ".join(", " => keys %plugins)."\n";
}

exit 0;


sub get_tags {
  my $obj = shift;
  my $source = shift;
  my $tags;

  $tags =
    $source eq 'options' ?
      { map { exists $opt->{$_} ? ($_=>$opt->{$_}) : () } keys %known_tags }
    :
    $source eq 'filename' ?
      scan_filename($obj->file, $opt->{'capture-pattern'})
    :
    $source =~ /^id3v(1|2)$/ ?
      ($obj->filetype eq 'mp3' ? $obj->get_tags($1) : {})
    :
    $source eq 'flac' ?
      ($obj->filetype eq 'flac' ? $obj->get_tags() : {})
    :
    $source eq 'audio' ?
      $obj->get_audio_info
    :
    $source eq 'codec' ?
      $obj->get_codec_info
    :
    die "unrecognized tag source $source";

  $tags->{PATH} = realpath($obj->file);     # pseudo tag

  return normalize_tags($tags);
}

sub set_tags {
  my $obj = shift;
  my $tags = shift;

  for (grep exists $opt->{$_} => keys %known_tags) {
    $tags->{$_} = $opt->{$_};
  }

  my $file = $tags->{PATH};

  my %set_tags =
    map { defined $tags->{$_} ? ($_ => $tags->{$_}) : () }
      keys %known_tags;

  if ($opt->{dry}) {
    print "setting tags for $file\n";
  }
  else {
    $obj->set_tags($tags);
  }

  if ($sources{filename}) {
    my $newfile = format_filename($opt->{'rename-pattern'}, $tags);

    $newfile = join '/' => ($opt->{library}, $newfile) if $opt->{library};
    $newfile = join '.' => $newfile, $mime2ext{filetype($file)};

    if ($newfile ne $file) {
      if ($opt->{dry}) {
        print "rename: $file => $newfile\n";
      }
      else {
        ensure_dir(dirname($newfile));

        rename $file => $newfile or
          die "mv $file => $newfile failed: $!";
      }
    }
  }
}

sub parse_options {

  my $source_option = sub {
    my ($source, $value) = @_;
    $opt->{$source} = $value;
    $sources{$source} = 1+(keys %sources) if $value;
  };

  my @getopt = (
    qw/get|g
       set|s
       help|h
       verbose|v
       version|V
       dry|n
       library|L=s
       mime
       set-sources|S
       rename-pattern|p=s
       capture-pattern|P=s/,
    (map { +"$_|$known_sources{$_}!" => $source_option } keys %known_sources),
    (map "$_|".lc($_)."|$known_tags{$_}:s" => keys %known_tags),
  );

  Getopt::Long::Configure('bundling', 'no_ignorecase');
  GetOptions($opt, @getopt) or die;

  if ($opt->{get} && !defined $opt->{'capture-pattern'}) {
    warn "will not scrape filenames (specify --capture-pattern)\n" if
      $opt->{filename};
    $opt->{filename} = 0;
  }

  unless ($opt->{'set-sources'}) {
    for my $source (@default_sources) {
      next if exists $opt->{$source} && !$opt->{$source};
      next if exists $sources{$source};
      $sources{$source} = 1+(keys %sources);
    }
  }
}

sub read_config {
  my $file = shift;
  my %config;

  open my $fh, '<', $file or
    die "error reading config file $file: $!";

  while (<$fh>) {
    chomp;
    s/^\s+//;
    s/\s+$//;

    next if not $_;
    next if substr($_, 0, 1) eq '#';

    if (/^([^= ]+)\s*=\s*(.*)$/) {
      $config{$1} = $2;
    }
    else {
      die qq{config syntax error, line $.: "$_"};
    }
  }
  
  close $fh or
    die "error reading config file $file: $!";

  return \%config;
}

sub load_plugin {
  my $codec = shift;
  my $pkgbase = "Audio::SuperTag::Plugin";
  my $pkg = join '::' => $pkgbase, uc $codec;
  my $syms = do { no strict 'refs'; \%{"${pkgbase}::"} };

  return $pkg if exists $syms->{uc($codec).'::'};
  return eval "require $pkg" ? $pkg : undef;
}

sub normalize_tags {
  my $tags = shift;

  # standardize on uppercase tag names

  %$tags = map { uc $_ => $tags->{$_} } keys %$tags;

  if (($tags->{TRACKNUM}||'') =~ /^(\d+)/) {
    $tags->{TRACKNUM} = $1;
  }
  elsif ($tags->{TRACKNUM}) {
    die "bad track tag: $tags->{TRACKNUM}";
  }

  for (keys %$tags) {
    if ('ARRAY' eq ref $tags->{$_}||'') {
      $tags->{$_} = join "\n" => @{$tags->{$_}};
    }
  }

  return $tags;
}

sub filetype {
  my $file = shift;

  if ($opt->{mime}) {
    open my $fh, '-|', '/usr/bin/file', '-i', '-b', $file or
      die "error running file(1): $!";

    my $mime = <$fh>; chomp $mime;

    close $fh or
      die "error running file(1): $!";

    return $mime;
  }
  else {
    my $ext = ($file =~ /\.([^\.]+)$/)[0];

    return $ext2mime{$ext};
  }
}

sub scan_filename {
  my $file = shift;
  my $pattern = shift;
  my $delim = '_';
  my %spec = map { $known_tags{$_} => $_ } keys %known_tags;
  my @match_names;
 
  $pattern =~ s!([^a-zA-Z0-9_ %/-])!\\$1!g;
  $pattern =~ s/%([a-zA-Z])/push @match_names, $spec{$1}; "(.*?)"/eg;

  for my $try ($file, basename($file)) {
    if ((my @matches = ($try =~ qr/$pattern/))) {
      my %tags;

      for (my $i=0; $i<@matches; $i++) {
        $tags{$match_names[$i]} = $matches[$i];
      }

      return \%tags;
    }
  }

  return {};
}

sub format_filename {
  my $pattern = shift;
  my $tags = shift;
  my %abbrev = map { $known_tags{$_} => $_ } keys %known_tags;

  my $specsub = sub {
    my ($width, $format) = @_;
    my $value = $tags->{$abbrev{$format}};
    my $type;

    $width = '' if not defined $width;
    $value = '' if not defined $value;
    $type = $format eq 'T' ? 'd' : 's';

    return sprintf "%${width}${type}" => path_sanitize($value);
  };

  my $file = $pattern;
  $file =~ s/%(\d*)([a-zA-Z])/$specsub->($1,$2)/ge;
  return $file;
}

sub path_sanitize {
  my $str = shift;

  # TODO crib odd char set from soundjuicer?
  $str =~ s! !_!g;
  $str =~ s![^[:print:]]!_!g;
  $str =~ s![/\\\*:]!_!g;

  return $str;
}

sub ensure_dir {
  my $dir = shift;
  my @parts = split m{/} => $dir;
  my $x = '';

  while (@parts) {
    $x .= '/' . shift @parts;
    if ($x && !-d $x) {
      mkdir $x or $!{EEXIST} or do die "mkdir error for $x: $!";
    }
  }
}

sub dirname {
  return $1 if $_[0] =~ m{^(.+)/([^/]+)$};
  return;
}

sub basename {
  return $_[0] =~ m{([^/]+)$} ? $1 : $_[0];
}

sub hash_union {
  my %h;

  for my $k (map keys %$_ => @_) {
    for my $v (map $_->{$k} => @_) {
      $h{$k} = $v unless defined $h{$k};
    }
  }

  return \%h;
}


__END__

=head1 SYNOPSIS

supertag - manage your music collection like a real man.

=head1 DESCRIPTION

TODO write me

=head1 EXAMPLES

TODO write me

=head1 OPTIONS

operating modes:
  -g get tag info (the default mode)
  -s set tag info

operands:
  -1 operate on id3v1 tags (mp3 only)
  -2 operate on id3v2 tags (mp3 only)
  -F operate on flac tags (flac only)
  -N operate on filenames
  -p PATTERN format string for renaming files
  -P PATTERN format string for scraping filenames

tags:
  -A album
  -a artist
  -t title
  -T track number
  -y year
  -g genre
  -c composer
  -C comment

flags:
  -m, --mime     use file(1) to determine file type (slower, default no)
  -n, --dry      dry run (don't modify anything)
  -v, --verbose  verbose

=head1 AUTHOR

Alan Grow <agrow+nospam@thegotonerd.com>

=head1 COPYRIGHT

Copyright (C) 2008 by Alan Grow

This application is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.3 or, at
your option, any later version of Perl 5 you may have available.

=cut

